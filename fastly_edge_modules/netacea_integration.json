{
    "description": "Set of VCLs required to integrate Netacea services. Please note for full functionality Fastly support needs to enable proper handling of POST requests. Do not enable unless this has been done.",
    "id": "netacea_integration",
    "name": "Netacea Bot Detection integration",
    "properties": [
        {
            "description": "API Key",
            "label": "Netacea API Key",
            "name": "netacea_api_key",
            "required": true,
            "type": "string"
        },
        {
            "description": "Secret",
            "label": "Netacea Secret",
            "name": "netacea_secret",
            "required": true,
            "type": "string"
        },
        {
            "description": "Up to 5 comma separated URL paths that API Protector will ignore. Please start URL paths with a forward slash. Example: /test, /allowed/, /path/to/something",
            "label": "Netacea ignore list - URL Paths",
            "name": "netacea_ignore_list",
            "required": false,
            "type": "string"
        },
        {
            "description": "Name of the header containing client's real IP. Leave empty to use connecting IP.",
            "label": "Real IP Header Name",
            "name": "netacea_real_ip_header_name",
            "required": false,
            "type": "string"
        }
    ],
    "vcl": [
        {
            "priority": 45,
            "template": "# Change the shielding condition to account for restarts due to bot detection\nset var.fastly_req_do_shield = (req.restarts <= 1);\n# Reenable clustering. It gets turned off on restarts\nset req.http.Fastly-Force-Shield = \"1\";\n# Ignore list check\ndeclare local var.ignored BOOL;\ndeclare local var.netacea_request_path STRING;\ndeclare local var.netacea_ignore_list STRING;\ndeclare local var.netacea_first_ignored_path STRING;\ndeclare local var.netacea_second_ignored_path STRING;\ndeclare local var.netacea_third_ignored_path STRING;\ndeclare local var.netacea_fourth_ignored_path STRING;\ndeclare local var.netacea_fifth_ignored_path STRING;\n\nset var.netacea_ignore_list = table.lookup(Netacea_Config, \"ignore_list\");\nset var.ignored = false;\n\n# Extract and set ignored URL paths\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_first_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_second_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_third_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fourth_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fifth_ignored_path = regsub(re.group.1, \" \", \"\");\n}\n\n# Check request's URL path\nif (\n  std.prefixof(req.url.path, var.netacea_first_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_second_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_third_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fourth_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fifth_ignored_path)\n) {\n  set var.ignored = true;\n}\n\nif(var.ignored == false) {\n  # Invoke Netacea Bot Detection checking\n  call netacea_recv;\n}",
            "type": "recv"
        },
        {
            "priority": 45,
            "template": "# Ignore list check\ndeclare local var.ignored BOOL;\ndeclare local var.netacea_request_path STRING;\ndeclare local var.netacea_ignore_list STRING;\ndeclare local var.netacea_first_ignored_path STRING;\ndeclare local var.netacea_second_ignored_path STRING;\ndeclare local var.netacea_third_ignored_path STRING;\ndeclare local var.netacea_fourth_ignored_path STRING;\ndeclare local var.netacea_fifth_ignored_path STRING;\n\nset var.netacea_ignore_list = table.lookup(Netacea_Config, \"ignore_list\");\nset var.ignored = false;\n\n# Extract and set ignored URL paths\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_first_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_second_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_third_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fourth_ignored_path = regsub(re.group.1, \" \", \"\");\n  set var.netacea_ignore_list = regsub(var.netacea_ignore_list, \"([^,]+)\", \"\");\n}\n\nif (var.netacea_ignore_list ~ \"([^,]+)\") {\n  set var.netacea_fifth_ignored_path = regsub(re.group.1, \" \", \"\");\n}\n\n# Check request's URL path\nif (\n  std.prefixof(req.url.path, var.netacea_first_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_second_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_third_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fourth_ignored_path) ||\n  std.prefixof(req.url.path, var.netacea_fifth_ignored_path)\n) {\n  set var.ignored = true;\n}\n\nif(var.ignored == false) {\n  # Invoke Netacea Bot Detection checking\n  call netacea_deliver;\n}",
            "type": "deliver"
        },
        {
            "priority": 45,
            "template": "backend F_MitSvc {\n    .between_bytes_timeout = 100ms;\n    .connect_timeout = 500ms;\n    .dynamic = true;\n    .first_byte_timeout = 500ms;\n    .host = \"geo-mitigations.netacea.net\";\n    .max_connections = 200;\n    .port = \"443\";\n    .share_key = \"NetaceaGeoMitigations\";\n    .host_header = \"geo-mitigations.netacea.net\";\n    .always_use_host_header = true;\n    .ssl = true;\n    .ssl_cert_hostname = \"geo-mitigations.netacea.net\";\n    .ssl_check_cert = always;\n    .ssl_sni_hostname = \"geo-mitigations.netacea.net\";\n    .probe = {\n        .dummy = false;\n        .initial = 5;\n        .request = \"GET /_health HTTP/1.1\" \"Host: geo-mitigations.netacea.net\" \"Connection: close\" \"User-Agent: Varnish/fastly (healthcheck)\";\n        .threshold = 1;\n        .timeout = 2s;\n        .window = 5;\n        .expected_response = 200;\n    }\n}\n\n# BYPASS - disable Netacea integration\n# INGEST - set cookie to track visitors but do not mitigate\n# MITIGATE - enforce Netacea blocklist\ntable Netacea_Config {\n  \"integration_type\": \"MITIGATE\",\n  \"api_key\": \"{{netacea_api_key}}\",\n  \"secret_key\": \"{{netacea_secret}}\",\n  \"ignore_list\": \"{{netacea_ignore_list}}\",\n  \"real_ip_header_name\": \"{{netacea_real_ip_header_name}}\"\n}\n\nsub netacea_recv {\n  declare local var.netacea_mitSvc_authenticate BOOL;\n  declare local var.netacea_mitSvc_apiKey STRING;\n  declare local var.netacea_mitSvc_secret STRING;\n  declare local var.netacea_integration_type STRING;\n\n  set var.netacea_mitSvc_apiKey = table.lookup(Netacea_Config, \"api_key\");\n  set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");\n  set var.netacea_integration_type = table.lookup(Netacea_Config, \"integration_type\");\n\n  # Unset headers Netacea Set\n  unset req.http.netacea_processed;\n  if (req.restarts == 0 && fastly.ff.visits_this_service == 0) {\n    set req.http.netacea_best_mitigation_code = \"000\";\n    set req.http.netacea_match = \"0\";\n    set req.http.netacea_mitigate = \"0\";\n    set req.http.netacea_captcha = \"0\";\n    call set_netacea_ip_header;\n\n    unset req.http.mit_status;\n    unset req.http.netacea_bctype_string;\n    unset req.http.netacea_best_mitigation;\n    unset req.http.netacea_cookies;\n    unset req.http.netacea_mitata_captcha_cookie_expiry;\n    unset req.http.netacea_mitata_captcha_cookie_value;\n    unset req.http.netacea_mitata_must_reauthenticate;\n    unset req.http.netacea_require_revalidation;\n    unset req.http.netacea_set_cookies;\n    unset req.http.X-Netacea-Api-Key;\n    unset req.http.X-Netacea-Captcha-Status;\n    unset req.http.X-Netacea-UserId;\n    if (var.netacea_integration_type != \"BYPASS\") {\n      set var.netacea_mitSvc_authenticate = true;\n\n      # Parse & validate _mitata cookie. Unsets cookie if invalid.\n      call process_netacea_mitata_cookie;\n    }\n  } else {\n    if (req.http.netacea_best_mitigation == \"block\") {\n      error 403;\n    }\n  }\n\n  if (req.http.Cookie:_mitata && !req.http.netacea_mitata_must_reauthenticate) {\n    # Cookie is valid and not expired, no need for additional authentication\n    set var.netacea_mitSvc_authenticate = false;\n  }\n\n  # set User ID, integration type, and integration version so they can be logged\n  set req.http.mitigation_user_id = req.http.X-Netacea-UserId;\n  set req.http.integration_type = \"fastly/magento\";\n  set req.http.integration_version = \"4.3.2\";\n\n  if (var.netacea_mitSvc_authenticate) {\n    set req.http.netacea_set_cookies = \"1\";\n  }\n\n  if (var.netacea_integration_type == \"MITIGATE\" && var.netacea_mitSvc_authenticate) {\n    set req.backend = F_MitSvc;\n    if (req.backend.healthy) {\n      unset req.http.netacea_match;\n      unset req.http.netacea_mitigate;\n      unset req.http.netacea_captcha;\n      unset req.http.Cookie:_mitata;\n\n      set req.http.netacea_origin_method = req.method;\n      set req.http.netacea_processed = \"1\";\n      set req.http.netacea_origin_host = req.http.host;\n      set req.http.netacea_origin_url = req.url;\n      if (req.url != \"/AtaVerifyCaptcha\") {\n        set req.method = \"GET\";\n        set req.url = \"/\";\n      }\n      set req.http.X-Netacea-Api-Key = var.netacea_mitSvc_apiKey;\n      return(pass);\n    }\n  }\n}\n\nsub netacea_deliver {\n  call netacea_calculate_best_mitigation;\n\n  if (req.http.netacea_processed == \"1\") {\n    set req.http.mit_status = resp.status;\n    if (resp.status != 200) {\n      // Unset these because we're not mitigating anything.\n      set req.http.netacea_best_mitigation = \"\";\n      set req.http.netacea_bctype_string = \"\";\n      // If the AtaVerifyCaptcha is not returning a 200 assume it was not successful and do not set cookies\n      if(req.url == \"/AtaVerifyCaptcha\") {\n        unset resp.http.Set-Cookie;\n        set req.http.netacea_set_cookies = \"0\";\n      }\n    }\n\n    set req.http.netacea_mitata_captcha_cookie_value = resp.http.x-netacea-mitatacaptcha-value;\n    set req.http.netacea_mitata_captcha_cookie_expiry = resp.http.x-netacea-mitatacaptcha-expiry;\n    call set_netacea_cookies;\n\n    if(req.url == \"/AtaVerifyCaptcha\") {\n      return(deliver);\n    }\n\n    set req.http.host = req.http.netacea_origin_host;\n    set req.url = req.http.netacea_origin_url;\n    set req.method = req.http.netacea_origin_method;\n\n    unset req.http.netacea_origin_url;\n    unset req.http.netacea_origin_host;\n    unset req.http.netacea_origin_method;\n    unset req.http.X-Netacea-Api-Key;\n\n    if (req.http.netacea_best_mitigation != \"captcha\") {\n      restart;\n    }\n    set resp.status = 403;\n    set resp.http.content-type = \"text/html; charset=UTF-8\";\n    return(deliver);\n  }\n  call set_netacea_cookies;\n}\n\nsub set_netacea_ip_header {\n  declare local var.ip_header_name STRING;\n  set var.ip_header_name = table.lookup(Netacea_Config, \"real_ip_header_name\");\n\n  declare local var.ip_header_value STRING;\n  set var.ip_header_value = if (std.strlen(var.ip_header_name) > 0, header.get(req, var.ip_header_name), \"\");\n\n  set req.http.X-Netacea-Client-IP = if (std.strlen(var.ip_header_value) > 0, var.ip_header_value, client.ip);\n}\n\nsub set_netacea_cookies {\n  if (req.http.netacea_set_cookies == \"1\") {\n    # Remove any existing netacea cookies being set\n    declare local var.ignored BOOL;\n    set var.ignored = setcookie.delete_by_name(resp, \"_mitata\");\n    set var.ignored = setcookie.delete_by_name(resp, \"_mitatacaptcha\");\n\n    call set_mitata_cookie;\n\n    if (req.http.netacea_mitata_captcha_cookie_value && req.http.netacea_mitata_captcha_cookie_expiry) {\n      add resp.http.Set-Cookie= \"_mitatacaptcha=\" + req.http.netacea_mitata_captcha_cookie_value + \"; Max-Age=\" + req.http.netacea_mitata_captcha_cookie_expiry + \"; Path=/;\";\n    }\n  }\n}\n\ntable Netacea_Match_Dict {\n  \"0\": \"\",\n  \"1\": \"ua\",\n  \"2\": \"ip\",\n  \"3\": \"visitor\",\n  \"4\": \"datacenter\",\n  \"5\": \"customer_session\",\n  \"6\": \"organisation\",\n  \"7\": \"asn\",\n  \"8\": \"country\",\n  \"9\": \"combination\"\n}\n\ntable Netacea_Mitigate_Dict {\n  \"0\": \"\",\n  \"1\": \"blocked\",\n  \"2\": \"allow\",\n  \"3\": \"hardblocked\"\n}\n\ntable Netacea_Best_Mitigations_Dict {\n  \"0\": \"\",\n  \"1\": \"block\",\n  \"2\": \"allow\",\n  \"3\": \"block\"\n}\n\ntable Netacea_Best_Mitigations_Captcha_Dict {\n  \"1\": \"captcha\",\n  \"2\": \"\",\n  \"3\": \"captcha\",\n  \"4\": \"\",\n  \"5\": \"captcha\"\n}\n\ntable Netacea_Captcha_Dict {\n  \"0\": \"\",\n  \"1\": \"captcha_serve\",\n  \"2\": \"captcha_pass\",\n  \"3\": \"captcha_fail\",\n  \"4\": \"captcha_cookiepass\",\n  \"5\": \"captcha_cookiefail\",\n}\n\nsub netacea_calculate_best_mitigation {\n  if (!req.http.netacea_bctype_string) {\n    declare local var.netacea_match STRING;\n    declare local var.netacea_mitigate STRING;\n    declare local var.netacea_captcha STRING;\n    declare local var.netacea_match_string STRING;\n    declare local var.netacea_mitigate_string STRING;\n    declare local var.netacea_captcha_string STRING;\n    declare local var.netacea_captcha_mitigate_string STRING;\n\n    declare local var.netacea_best_mitigation STRING;\n    declare local var.netacea_bctype_string STRING;\n\n    if (resp.http.x-netacea-match) { # If netacea mitigation service returns a match, use this\n      set var.netacea_match = resp.http.x-netacea-match;\n    } elseif (req.http.netacea_match) { # If cookie has a match, use this\n      set var.netacea_match = req.http.netacea_match;\n    } else {\n      set var.netacea_match = \"0\";\n    }\n\n    if (resp.http.x-netacea-mitigate) { # If netacea mitigation service returns a mitigate, use this\n      set var.netacea_mitigate = resp.http.x-netacea-mitigate;\n    } elseif (req.http.netacea_mitigate) { # If cookie has a mitigate, use this\n      set var.netacea_mitigate = req.http.netacea_mitigate;\n    } else {\n      set var.netacea_mitigate = \"0\";\n    }\n\n    if (resp.http.x-netacea-captcha) { # If netacea mitigation service returns a captcha, use this\n      set var.netacea_captcha = resp.http.x-netacea-captcha;\n    } elseif (req.http.netacea_captcha) { # If cookie has a captcha, use this\n      set var.netacea_captcha = req.http.netacea_captcha;\n    } else {\n      set var.netacea_captcha = \"0\";\n    }\n\n\n    # IP, UA, Visitor, Datacentre etc\n    if (var.netacea_match) {\n      set var.netacea_match_string = table.lookup(Netacea_Match_Dict, var.netacea_match, \"unknown\");\n\n      if (var.netacea_match_string != \"\") {\n        set var.netacea_bctype_string = var.netacea_match_string + \"_\";\n      }\n    }\n\n    # BLOCK, TRUST, HARDBLOCK etc\n    if (var.netacea_mitigate) {\n      set var.netacea_mitigate_string = table.lookup(Netacea_Mitigate_Dict, var.netacea_mitigate, \"unknown\");\n\n      if (var.netacea_mitigate_string != \"\") {\n        set var.netacea_bctype_string = var.netacea_bctype_string + var.netacea_mitigate_string;\n      }\n\n      set var.netacea_best_mitigation = table.lookup(Netacea_Best_Mitigations_Dict, var.netacea_mitigate, \"no-best-mitigation\");\n      if (var.netacea_best_mitigation == \"no-best-mitigation\") {\n        set var.netacea_best_mitigation = \"\";\n      }\n    }\n\n    if (var.netacea_captcha) {\n      # 2 and 3 can only be set on /AtaVerifyCaptcha requests\n      # If it's not 2 or 3 then set them to the cookie variant\n      if (req.url != \"/AtaVerifyCaptcha\") {\n        if (var.netacea_captcha == \"2\") {\n          set var.netacea_captcha = \"4\";\n        } elseif (var.netacea_captcha == \"3\") {\n          set var.netacea_captcha = \"5\";\n        }\n      }\n      set var.netacea_captcha_string = table.lookup(Netacea_Captcha_Dict, var.netacea_captcha, \"unknown\");\n\n      if (var.netacea_captcha_string != \"\") {\n        set var.netacea_bctype_string = var.netacea_bctype_string + \",\" + var.netacea_captcha_string;\n      }\n      set var.netacea_captcha_mitigate_string = table.lookup(Netacea_Best_Mitigations_Captcha_Dict, var.netacea_captcha, \"no-best-captcha-mitigation\");\n      if (var.netacea_captcha_mitigate_string != \"no-best-captcha-mitigation\") {\n        set var.netacea_best_mitigation = var.netacea_captcha_mitigate_string;\n      }\n    }\n\n    set req.http.netacea_bctype_string = var.netacea_bctype_string;\n    set req.http.netacea_best_mitigation = var.netacea_best_mitigation;\n    set req.http.netacea_best_mitigation_code = var.netacea_match + var.netacea_mitigate + var.netacea_captcha;\n\n    # Require re-validation if hard blocked\n    if (var.netacea_mitigate == \"3\") {\n      set req.http.netacea_require_revalidation = \"1\";\n    }\n\n    # Require re-validation if not passed captcha\n    if (var.netacea_mitigate == \"1\" && var.netacea_captcha != \"2\" && var.netacea_captcha != \"4\") {\n      set req.http.netacea_require_revalidation = \"1\";\n    }\n\n    # Unset x-netacea headers\n    # unset resp.http.x-netacea-match;\n    # unset resp.http.x-netacea-mitigate;\n    # unset resp.http.x-netacea-captcha;\n\n  }\n}\n\nsub set_mitata_cookie {\n    declare local var.netacea_mitSvc_secret STRING;\n    set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");\n\n    declare local var.netacea_integration_type STRING;\n\n    set var.netacea_integration_type = table.lookup(Netacea_Config, \"integration_type\");\n\n    # Set User ID for new user\n    if (!req.http.X-Netacea-UserId) {\n      # \"c\" prefix indicates the ID was generated in a Netacea customer integration\n      set req.http.X-Netacea-UserId = \"c\" + randomstr(15, \"1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n    }\n\n    # Declare vars for _mitata cookie parts\n    declare local var.netacea_mitata_cookie_full_value STRING;\n    declare local var.netacea_ataCookie_stringValue STRING;\n    declare local var.netacea_ataCookie_HMAC STRING;\n    declare local var.netacea_mitSvc_exp STRING;\n    declare local var.netacea_mitSvc_sig STRING;\n    declare local var.netacea_mitSvc_userId STRING;\n    declare local var.netacea_mitigation_code STRING;\n    declare local var.netacea_client_ip_time_hash STRING;\n    set var.netacea_mitigation_code = req.http.netacea_best_mitigation_code;\n    set var.netacea_mitSvc_userId = req.http.X-Netacea-UserId;\n\n    # Set cookie expiry\n    if (req.http.netacea_require_revalidation == \"1\") {\n      // Serving captcha. Set time in past to force re-validation until passed.\n      set var.netacea_mitSvc_exp = time.units(\"s\", time.sub(now, 1m));\n    } else {\n      set var.netacea_mitSvc_exp = time.units(\"s\", time.add(now, 1m));\n    }\n\n    # Create signature\n    set var.netacea_client_ip_time_hash = digest.hmac_sha256(var.netacea_mitSvc_secret, req.http.X-Netacea-Client-IP + var.netacea_mitSvc_exp);\n    if (var.netacea_client_ip_time_hash ~ \"0x(.*)\") {\n      set var.netacea_client_ip_time_hash = re.group.1;\n    }\n    set var.netacea_ataCookie_stringValue = var.netacea_mitSvc_exp + \"_/@#/\" + var.netacea_mitSvc_userId + \"_/@#/\" + digest.base64(var.netacea_client_ip_time_hash) + \"_/@#/\" + var.netacea_mitigation_code;\n    set var.netacea_ataCookie_HMAC = digest.hmac_sha256(var.netacea_mitSvc_secret, var.netacea_ataCookie_stringValue);\n    if (var.netacea_ataCookie_HMAC ~ \"0x(.*)\") {\n      set var.netacea_ataCookie_HMAC = re.group.1;\n    }\n\n    # Set signed cookie\n    set var.netacea_mitSvc_sig = digest.base64(var.netacea_ataCookie_HMAC);\n    set var.netacea_mitata_cookie_full_value = var.netacea_mitSvc_sig + \"_/@#/\" + var.netacea_ataCookie_stringValue;\n    add resp.http.Set-Cookie= \"_mitata=\" + var.netacea_mitata_cookie_full_value + \"; Max-Age=\" + time.units(\"s\", 1d) + \"; Path=/;\";\n\n    # set user ID so that it can be logged. Could be dome somewhere else?\n    set req.http.mitigation_user_id = var.netacea_mitSvc_userId;\n}\n\n# Read _mitata cookie to get User ID and any existing mitigation\n# Unsets _mitata if signature is not valid\n# Uses:\n#   req.http.Cookie:_mitata\n# May set:\n#   req.http.X-Netacea-UserId\n#   req.http.netacea_match\n#   req.http.netacea_mitigate\n#   req.http.netacea_captcha\n#   req.http.netacea_mitata_must_reauthenticate\nsub process_netacea_mitata_cookie {\n  declare local var.netacea_mitSvc_secret STRING;\n  set var.netacea_mitSvc_secret = table.lookup(Netacea_Config, \"secret_key\");\n\n  declare local var.netacea_cookie_sig STRING;\n  declare local var.netacea_cookie_payload STRING;\n  declare local var.netacea_cookie_expiry STRING;\n  declare local var.netacea_client_ip_time_hash STRING;\n  declare local var.netacea_real_client_ip_time_hash STRING;\n  declare local var.netacea_cookie_HMAC STRING;\n  declare local var.netacea_cookie_real_value STRING;\n\n  if (req.http.Cookie:_mitata) {\n    if (req.http.Cookie:_mitata ~ \"^(.*)_\\/@#\\/((\\d+)_\\/@#\\/(.+)_\\/@#\\/(.+)_\\/@#\\/((\\d)(\\d)(\\d)))$\") {\n      set var.netacea_cookie_sig = re.group.1;\n      set var.netacea_cookie_payload = re.group.2;\n      set var.netacea_cookie_expiry = re.group.3;\n      set req.http.X-Netacea-UserId = re.group.4;\n      set var.netacea_client_ip_time_hash = re.group.5;\n      set req.http.netacea_match = re.group.7;\n      set req.http.netacea_mitigate = re.group.8;\n      set req.http.netacea_captcha = re.group.9;\n      set var.netacea_cookie_real_value = var.netacea_cookie_expiry + \"_/@#/\" +  req.http.X-Netacea-UserId + \"_/@#/\" + var.netacea_client_ip_time_hash + \"_/@#/\" + req.http.netacea_match + req.http.netacea_mitigate + req.http.netacea_captcha;\n\n      # Calculate HMACs\n      set var.netacea_cookie_HMAC = digest.hmac_sha256(var.netacea_mitSvc_secret, var.netacea_cookie_real_value);\n      if (var.netacea_cookie_HMAC ~ \"0x(.*)\") {\n        set var.netacea_cookie_HMAC = re.group.1;\n      }\n\n      set var.netacea_real_client_ip_time_hash = digest.hmac_sha256(var.netacea_mitSvc_secret, req.http.X-Netacea-Client-IP + var.netacea_cookie_expiry);\n      if (var.netacea_real_client_ip_time_hash ~ \"0x(.*)\") {\n        set var.netacea_real_client_ip_time_hash = re.group.1;\n      }\n\n      if (var.netacea_cookie_sig != digest.base64(var.netacea_cookie_HMAC)) {\n        # Delete cookie with invalid HMAC\n        unset req.http.Cookie:_mitata;\n        # Unset these headers as we can no longer trust them:\n        unset req.http.X-Netacea-UserId;\n        unset req.http.netacea_match;\n        unset req.http.netacea_mitigate;\n        unset req.http.netacea_captcha;\n      } else {\n        if (time.is_after(now, std.time(var.netacea_cookie_expiry, now)) || digest.base64(var.netacea_real_client_ip_time_hash) != var.netacea_client_ip_time_hash ) {\n          # Cookie is expired or IP has changed\n          set req.http.netacea_mitata_must_reauthenticate = \"1\";\n        }\n      }\n    } else {\n      # Delete cookie which does not match regex\n      unset req.http.Cookie:_mitata;\n    }\n  }\n\n  # Cannot have _mitatacaptcha without _mitata\n  if (!req.http.Cookie:_mitata) {\n    unset req.http.Cookie:_mitatacaptcha;\n  }\n}\n",
            "type": "init"
        }
    ],
    "version": 6
}
